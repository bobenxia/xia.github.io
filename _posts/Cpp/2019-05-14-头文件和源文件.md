---
layout: post
title: 头文件和源文件分离
category: cpp
tags: C++
keywords: 头源分离
description:
---

## 概览

||非模板类型(none-template)|模板类型(template)|
|:----:|:----|:----|
|头文件(.h)|1. 全局变量申明（带 extern 限定符）<br>2. 全局函数的申明<br>3. 带 inline 限定符的全局函数的定义<br>4. 类的定义<br>5. 类函数成员和数据成员的申明（在类内部）<br>6. 类定义内的函数定义（相当于 inline ）<br>7. 带 static const 限定符的数据成员在类内部的初始化 <br>8. 带 inline 限定符的类定义外的函数定义 <br>|1. 带inline限定符的全局模板函数的申明和定义<br>2. 模板类的定义<br>3. 模板类成员的申明和定义（定义可以放在类内或者类外，类外不需要写 inline）|
|实现文件(.cpp)	|1. 全局变量的定义（及初始化）<br>2. 全局函数的定义<br>3. 类函数成员的定义<br>4. 类带 static 限定符的数据成员的初始化|(无)|

*申明：declaration
*定义：definition

## 头文件

头文件的所有内容，都必须包含在

```h
#ifndef {Filename}
#define {Filename}

//{Content of head file}

#endif
```

这样才能保证头文件被多个其他文件引用(include)时，内部的数据不会被多次定义而造成错误

## inline 限定符
在头文件中，可以对函数用inline限定符来告知编译器，这段函数非常的简单，可以直接嵌入到调用定义之处。

当然inline的函数并不一定会被编译器作为inline来实现，如果函数过于复杂，编译器也会拒绝inline。

因此简单说来，代码最好短到只有3-5行的才作为inline。有循环，分支，递归的函数都不要用做inline。

对于在类定义内定义实现的函数，编译器自动当做有inline请求（也是不一定inline的）。因此在下边，我把带有inline限定符的函数成员和写在类定义体内的函数成员统称为“要inline的函数成员”

## 非模板类型
### 全局类型
就像前面笼统的话讲的：申明写在.h文件。

对于函数来讲，没有实现体的函数，就相当于是申明；而对于数据类型（包括基本类型和自定义类型）来说，其申明就需要用extern来修饰。

然后在.cpp文件里定义、实现或初始化这些全局函数和全局变量。

不过导师一直反复强调：不许使用全局函数和全局变量。用了之后造成的后果，目前就是交上去的作业项目会扣分。当然不能用自有不能用的理由以及解决方案，不过不在目前的讨论范围内。



### 自定义类型
对于自定义类型，包括类（class）和结构体（struct），它们的定义都是放在.h文件中。其成员的申明和定义就比较复杂了，不过看上边的表格，还是比较清晰的。

#### 函数成员
函数成员无论是否带有static限定符，其申明都放在.h文件的类定义内部。

对于要inline的函数成员其定义放在.h文件；其他函数的实现都放在.cpp文件中。

#### 数据成员
数据成员的申明与定义都是放在.h文件的类定义内部。对于数据类型，关键问题是其初始化要放在什么地方进行。

对于只含有static限定符的数据成员，它的初始化要放在.cpp文件中。因为它是所有类对象共有的，因此必须对它做合适的初始化。

对于只含有const限定符的数据成员，它的初始化只能在构造函数的初始化列表中完成。因为它是一经初始化就不能重新赋值，因此它也必须进行合适的初始化。

对于既含有static限定符，又含有const限定符的数据成员，它的初始化和定义同时进行。它也是必须进行合适的初始化

对于既没有static限定符，又没有const限定符的数据成员，它的值只针对本对象可以随意修改，因此我们并不在意它的初始化什么时候进行。



## 模板类型

C++中，模板是一把开发利器，它与C#，Java的泛型很相似，却又不尽相同。以前，我一直只觉得像泛型，模板这种东西我可能一辈子也不可能需要使用到。但是在导师的强制逼迫使用下，我才真正体会到模板的强大，也真正知道要如何去使用模板，更进一步是如何去设计模板。不过这不是三言两语可以讲完的，就不多说了。

对于模板，最重要的一点，就是在定义它的时候，编译器并不会对它进行编译，因为它没有一个实体可用。

只有模板被具体化（specialization）之后（用在特定的类型上），编译器才会根据具体的类型对模板进行编译。

所以才定义模板的时候，会发现编译器基本不会报错（我当时还很开心的：我写代码尽然会没有错误，一气呵成），也做不出智能提示。但是当它被具体用在一个类上之后，错误就会大片大片的出现，却往往无法准确定位。

因此设计模板就有设计模板的一套思路和方式，但是这跟本文的主题也有偏。



因为模板的这种特殊性，它并没有自己的准确定义，因此我们不能把它放在.cpp文件中，而要把他们全部放在.h文件中进行书写。这也是为了在模板具体化的时候，能够让编译器可以找到模板的所有定义在哪里，以便真正的定义方法。

至于模板类函数成员的定义放在哪里，导师的意见是放在类定义之外，因为这样当你看类的时候，一目了然地知道有那些方法和数据；我在用Visual Studio的时候查看到其标准库的实现，都是放在类内部的。

可能是我习惯了C#的风格，我比较喜欢把它们都写在类内部，也因为在开发过程中，所使用的编辑器都有一个强大的功能：代码折叠。

当然还有其他原因就是写在类外部，对于每一个函数成员的实现都需要把模板类型作为限定符写一遍，把类名限定符也要写一遍。