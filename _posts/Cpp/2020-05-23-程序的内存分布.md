---
layout: post
title: C/C++ 程序的内存分布
category: cpp
tags: C++
keywords: 程序内存分布
description:
---

*程序在内存中的分布情况，一般说内存，指的是计算机的随机存储器(RAM)，程序都是在这里运行的*

## 0. 程序内存布局

- 栈区(stack)：由编译器自动分配释放，存储函数的参数值，局部变量值等，其操作方法类似于数据结构中的栈

- 堆区(heap)：一般由程序员申请和释放，与数据结构中的堆没有任何关系，分配方式类似于链表

- 全局/静态区(static)：全局变量和静态变量是存储在一起的，在程序编译时分配

- 文字常量区：存储常量字符串

- 程序代码区：存储函数体(类的成员函数、全局函数)的二进制代码

## 1. 栈内存

程序自动向操作系统申请分配以及回收，速度快，使用方便，但是程序员无法控制，如果分配失败，抛出栈溢出错误

**注意点**

- const 局部变量也存储在栈区，栈区向地址减小的方向增长

- 系统为变量在栈上申请内存后，CPU 需要不断地判断变量是否已结束使用的生命周期，如果生命周期结束，系统就会释放为这个变量申请的栈内存，这样一来随着在栈上申请的变量增多，会对 CPU 造成额外的消耗

## 2. 堆内存

程序员向操作系统申请一段内存，当系统收到程序的申请时，会遍历一个记录空内存结点的链表，找到第一个空间大于或等于所申请空间的堆结点，将该空闲结点从链表中删除，并将该结点的空间分配给程序，如果链表中空闲结点的空间大于申请空间的大小，系统会自动将对于的部分放入空闲链表中，故容易造成内存的碎片化，分配速度较慢，地址不连续

**注意点**

- 程序员申请的内存必须由程序员负责释放，否则会导致内存泄漏，堆的增长方向与内存地址的增长方向相同，因此在堆区上申请空间理论上是没有大小限制的，但是受安装内存条的大小和系统以及其他程序的占用，不是无限大的

- 程序员申请在堆上的内存，是由程序员自己管理的，不像栈上的变量那样，需要消耗 CPU 资源判断变量的生命周期，所以不会对 CPU 造成额外的消耗，这也是程序员申请堆上内存的优点

## 3. 堆和栈的比较

**申请方式**

- 栈(stack)：系统自动分配，如声明 int a; 系统自动在栈空间为 a 开辟空间

- 堆(heap)：程序猿申请，并指明大小，C 中 malloc 运算符，如 char* p = (char *)malloc(sizeof(char)); C++ 中 new 运算符，如int *n = new int(10);

*注意点*

指针 p 和 n 本身是在栈中，它们指向的地址空间是堆区的空间

**申请内存大小的限制**

- 栈(stack)：在 Windows 下，栈是向低地址方向扩展的，是一块连续的内存区域，也就是说栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows 下，一般栈的大小是 1M(这个是可以改的，总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间，将会抛出 overflow

- 堆(heap)：堆是向高地址方向扩展的，是不连续的内存区域，原因是系统使用链表的方式存储堆的空闲结点的，这个链表的遍历方向是由低到高的，堆获得的空间受限于计算系统中有效的虚拟内存，比较灵活
