# 编译内存


## 1、编译过程

编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。

- 编译预处理：处理以 # 开头的指令；
- 编译：将源码 .cpp 文件翻译成 .s 汇编代码；
- 汇编：将汇编代码 .s 翻译成目标代码.o；
- 链接：链接目标代码、其他目标代码和库文件

链接分为两种：

- **静态链接**：将依赖库与调用程序链接成一个完成的库或者可执行文件，运行的时候会将整个程序装到内存中，方便部署但是体积较大，依赖库的升级的时候需要重新编译；

  - gcc 链接顺序：从右到左，所以要把最基础实现的库放在最后
  - ```shell
    g++ ...  obj($?) -l(上层逻辑lib) -l(中间封装lib) -l(基础lib) -l(系统lib)  -o $@
    ``` 

- **动态链接**：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。


## 2、内存管理

C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。

- **栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。

- **堆**：动态申请的内存空间，就是由 `malloc` 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。

- **全局区/静态存储区**：存放全局变量和静态变量，程序运行结束操作系统自动释放

- **常量存储区**（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。

- **代码区**（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

  ```c++
  #include <iostream>
  using namespace std;
  
  /*
  说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
  */
  
  int g_var = 0; // g_var 在全局区（.data 段）
  char *gp_var;  // gp_var 在全局区（.bss 段）
  
  int main()
  {
      int var;                    // var 在栈区
      char *p_var;                // p_var 在栈区
      char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
      char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
      static int s_var = 0;       // s_var 为静态变量，存在静态存储区（.data 段）
      p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
      free(p_var);
      return 0;
  }
  ```

## 3、栈和堆的区别

  - 申请方式：栈是系统自动分配，堆是程序员主动申请。

  - 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。

  - **栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。**
    申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。
    存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。

    

## 4、变量的区别

  - **全局变量**：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。

  - **静态全局变量**：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话**，它作用于定义它的文件里，不能作用到其它文件里**，即被 `static` 关键字修饰过的变量具有文件作用域。

  - 局部变量

  - 静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在。

    

## 5、全局变量定义在头文件中有什么问题？

  当该头文件被多个文件 `include` 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。

  

## 6、内存对齐

  内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中

  内存对齐的优点：

  - 便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；
  - 提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。

  

## 7、类的大小

- 空类的大小为1
- 与普通成员变量有关，与成员函数和静态成员无关。
- 虚函数对类的大小有影响，是因为虚函数表指针的影响。



## 8、内存泄漏和预防

- 由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。

- 常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。

- 使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。

  

  预防

  1. **内部封装**：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。
  2. **智能指针**是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用