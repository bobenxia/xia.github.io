# 常见关键字

## 1、sizeof 和 strlen 的区别

1. strlen 是头文件 <cstring>  中的函数，sizeof 是 c++ 的运算符
2. strlen 测量的是字符串的实际长度，以 `\0`结束。而 sizeof 测量的是字符数组的分配大小
3. strlen 本身是库函数，因此在程序运行过程中，计算长度；而 sizeof 在编译时，计算长度
4. sizeof 的参数可以是类型，也可以是遍历；strlen 的参数必须是 char* 类型的变量

## 2、explicit 的作用

用来声明类构造函数是显示调用的，而非隐式调用，可以阻止构造函数时进行隐式转换。**只可用于修饰单参构造函数**。因为无参构造函数和多参构造函数本身就是显示调用的。

## 3、static 的作用

static 定义静态变量，静态函数。

- 保持变量内容持久：`static`作用于局部变量，改变了局部变量的生存周期，使得变量存在于定义后直到程序运行结束的这段时间。

- 隐藏：`static` 作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用）
- `static` 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。

## 4、static 在类中使用的注意事项

1. **静态成员变量在类内进行声明，在类外进行定义和初始化**。在类外进行定义和初始化的时候不要出现 `static`关键字。
2. 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象
3. **静态成员变量可以作为成员函数的参数，而普通成员变量不可以**
4. 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为**静态成员函数没有 `this`指针**。
5. 静态成员函数不能声明成虚函数、const 函数 和 volatile 函数

## 5、static 全局变量和普通全局变量的异同

存储方式相同，都是存储到静态存储区

作用域不同：静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它

## 6、const 作用及用法

作用：

- const 修饰成员变量，定义成 const 常量，相较于宏常量，可以进行类型检查，节省内存空间

- const 修饰函数参数，使得传递过来的函数参数的值不能改变

- const 修饰成员函数，使得成员函数不能修改还任何类型的成员变量，也不能调用非 const 成员函数

  ```c++
  void c_fun(int tmp) const // const 成员函数
  ```

在类中的用法：

- const 成员变量

  - const 成员变量只能在类内声明、定义，在**构造函数初始化列表中初始化**

- const 成员函数

  - 不能修改成员变量的值，只能访问成员变量

  - 不能调用非常量成员函数

  ```c++
    #include <iostream>
    using namespace std;
    
    class A
    {
    public:
    	int var;
    	A(int tmp) : var(tmp) {}
    	void c_fun(int tmp) const // const 成员函数
    	{
    		var = tmp; // error: assignment of member 'A::var' in read-only object. 在 const 成员函数中，不能修改任何类成员变量。		
    		fun(tmp); // error: passing 'const A' as 'this' argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。
    	}
    
    	void fun(int tmp)
    	{
    		var = tmp;
    	}
    };
    
    int main()
    {
        return 0;
    }
    ```

## 7、define 和 const 区别

- 编译阶段：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值
- 完全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型检查；const 可以
- 内存占用：define 定义的宏常量，在程序中使用多少此就会进行多少次替换，内存中就有多少个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份（const 局部变量存储在栈区）
- 调试：define 定义的宏常量不能调试，因为在编译预处理阶段进行替换

const 有点：

- 有数据类型，在定义时可以进行安全性检查
- 可调试
- 占用较少的空间

## 8、inline 关键字

- inline 时关键字，定义内联函数
- **类内定义的成员函数默认时内联函数**
- 如果在类内声明函数，类外定义函数时，**如果想将该函数定义成内联函数，则可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字**

好处：

- 消除函数调用的开销
- **内联函数可以在头文件中定义，并被多个 .cpp 文件 include，而不会出现重定义的错误**。（不加inlne是不可以在头文件中定义的）

## 9、inline 函数工作原理

- 内联函数不是在调用时发生控制转移关系，而是在编译阶段将**函数体嵌入**到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。
- 普通函数是将**程序执行**转移到被调用函数所存放的内存地址，当函数执行完后，返回执行此函数前的地方。转移操作需要保护现场，该过程需要较大的资源开销。

## 10、new 的作用

new 是 c++ 中的关键字，用来动态分配内存空间的 

## 11、new 和 malloc 如果判断是否申请到内存

- malloc：成功返回指向该内存的指针；失败返回 NULL 指针
- new：成功返回该对象类型的指针；失败抛出 bad_alloc 异常

## 12、delete 实现原理？delete 和 delete[] 的区别？

delete 实现原理：

- 首先执**行该对象所属类的析构函数**；
- 然后调用 `operator delete` 的标准库函数来释放所占的内存空间

delete 和 delete[] 的区别：

- delete 用来释放单个对象的所占空间，只会调用一次析构函数
- delete [] 用来释放数组空间，对数组中每个成员都会调用一次析构函数

## 13、new 和 malloc 的区别，delete 和 free 的区别

- malloc\free 是库函数，new\delete是关键字
- new 申请空间无需指定分配空间的大小，编译器会根据类型自动计算；malloc 在申请空间是，需要确定所申请空间的大小
- **new 返回类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc返回的是 void* 类型，需要进行强制类型转换，转换成对象类型的指针**。
- new 分配失败时，会抛出 bad_alloc 异常；malloc 分配失败时返回空指针。
- **对于自定义类型，new 首先调用 `operator new()` 申请空间（底层是 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然受调用 `operator delete()` 释放空间（底层通过 free 实现）**。malloc、free 无法进行自定义类的对象构造和析构
- new 操作符是在自由存储区上分配内存，而 malloc 函数是在堆上动态分配内存。（自由存储区不等于堆）

## 14、c 和 c++ struct

- c中，struct 是用户自定义数据类型；c++ 中 struct 是抽象数据类型，支持成员函数的定义
- C 语言中 `struct` 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 `struct` 可以和类一样，有访问权限，并可以定义成员函数。

## 15、为什么有了 class 还保留 struct

- C++ 是在 C 语言的基础上发展起来的，为了与 C 语言兼容，C++ 中保留了 `struct`。

## 16、class 和 struct 的异同

- struct 中默认访问级别是 public，默认继承级别是 public
- class 中默认访问级别是 private，默认继承级别是 private

## 17、extern c的作用？

extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

## 18、auto 类型推理的原理

编译器根据初始值来推算变量的类型，要求 auto 定义变量时必须有初始值

## 19、NULL和nullptr的区别

C++11以后又引入了nullptr，用以解决NULL在隐式转换和作为函数传入参数时的二义性问题。

NULL 是个常量，宏定义为 `#define NULL ((void*)0)`，很明显，NULL存在二义性，它既是整数，也是一个指针。

## 20、const 和 constexpr 的区别？

const并未区分出编译期常量和运行期常量
constexpr限定在了编译期常量