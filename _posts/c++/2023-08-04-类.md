# 5、类

## 1、什么是虚函数？

- 虚函数：被 virtual 关键字修饰的成员函数，就是虚函数
- 纯虚函数：在类声明时，加上 =0

## 2、纯虚函数和虚函数的区别？

- 使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；
- 定义方式不同、
- 析构函数最好定义成虚函数，因为当不定义成虚函数时，基类的指针访问派生类的对象，当析构该指针的时候，派生类的析构函数不会被调用

## 3、虚函数的实现机制

虚函数的实现是通过虚函数表来实现的，虚函数的地址存贮在虚函数表中，对象所在的内存空间中，保存了指向虚函数表的指针（称为虚表指针）。通过虚表指针可以找到类对应的虚函数表，虚函数表解决了基类和派生类的继承为题和类中成员函数的覆盖问题，当基类指针指向派生类对象的时候，这张虚函数表就指明了应该调用的函数。

虚函数表相关知识：

- 虚函数表存放的内容：类的虚函数的地址。
- 虚函数表的建立时间：编译阶段，即程序编译过程中会将虚函数的地址放在虚函数表中
- 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量

注：**虚函数表与类绑定，虚表指针和对象绑定。即类的不同对象的虚函数表是相同的，但是每个对象都有自己的虚表指针，来指向类的虚函数表**。

## 4、单继承和多继承的虚函数表结构

编译器处理虚函数表：

- 编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数
- 如果派生类没有重写定义基类的虚函数 A，则派生类的虚函数表中保存的时基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的
- 如果重写了，那么派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中
- 如果派生类重新定了了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 地址
- 子类的虚函数表中虚函数的顺序与父类一样，若子类重写父类虚函数，即在虚函数表中原位置覆盖即可。

## 5、如果禁止构造函数的使用？

加上 `=delete` 修饰符。

- 可以用来禁止复制/拷贝构造函数
- 一般在有自定义构造函数时，把默认构造函数 delete

```c++
#include <iostream>

using namespace std;

class A {
public:
    int var1, var2;
    A(){
        var1 = 10;
        var2 = 20;
    }
    A(int tmp1, int tmp2) = delete;
};

int main()
{
    A ex1;    
    A ex2(12,13); // error: use of deleted function 'A::A(int, int)'
    return 0;
}
```

## 6、构造函数、析构函数是否需要定义成虚函数？为什么?

构造函数一般不定义位虚函数，原因：

- 虚函数需要通过虚表指针调用，而虚表指针是创建了对象才有

析构函数一般定义成虚函数，原因：

析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针指向了派生类的对象时，当调用基类的析构函数，如果没有定义成虚函数，那么只能将基类的成员所占的空间释放掉，内存泄漏

## 7、如何避免拷贝

- = delete

## 8、如何减少构造函数开销

在构造函数中使用**类初始化列表**

因为用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，那么在进入构造函数之前，用户自定义类型会先初始化，然后调用构造函数过程，会进行复制操作，有拷贝构造的开销

## 9、多重继承会出现什么问题？

命名冲突和数据冗余问题

解决方案：

- 虚继承：**保证存在命名冲突的成员变量在派生类中只保留一份**，即使间接基类中的成员在派生类中只保留一份。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。

- ```c++
  #include <iostream>
  using namespace std;
  
  // 间接基类，即虚基类
  class Base1
  {
  public:
      int var1;
  };
  
  // 直接基类 
  class Base2 : virtual public Base1 // 虚继承
  {
  public:
      int var2;
  };
  
  // 直接基类 
  class Base3 : virtual public Base1 // 虚继承
  {
  public:
      int var3;
  };
  
  // 派生类
  class Derive : public Base2, public Base3
  {
  public:
      void set_var1(int tmp) { var1 = tmp; } 
      void set_var2(int tmp) { var2 = tmp; }
      void set_var3(int tmp) { var3 = tmp; }
      void set_var4(int tmp) { var4 = tmp; }
  
  private:
      int var4;
  };
  
  int main()
  {
      Derive d;
      return 0;
  }
  
  ```

## 10、空类占多少字节？

空类声明时编译器不会生成任何成员函数，只会生成1个字节的占位符；

空类定义的时候编译器会生成6个成员函数：

```c++
class A
{
public:
    A(){};                                       // 缺省构造函数
    A(const A &tmp){};                           // 拷贝构造函数
    ~A(){};                                      // 析构函数
    A &operator=(const A &tmp){};                // 赋值运算符
    A *operator&() { return this; };             // 取址运算符
    const A *operator&() const { return this; }; // 取址运算符（const 版本）
};
```

## 11、c++ 类对象的初始化顺序

构造函数调用顺序：

- 按照基类继承顺序，调用基类构造函数
- 按照成员变量声明顺序，调用成员变量所属类的构造函数
- 自身构造函数

析构函数相反

## 12、如何禁止一个类被实例化？

- 类中定义一个纯虚函数
- 构造函数私有化
- =delete

## 13、实例化一个对象需要哪些阶段？

- 分配空间
- 初始化。初始化随着对象的创建而进行，赋值在对象创建好后为其赋值。
- 复制。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。

## 14、静态绑定和动态绑定是怎么实现的？

- 静态绑定是指程序在编译阶段确定对象的类型
- 动态绑定是指程序在运行阶段确定对象的类型

对于类的成员函数，只有虚函数时动态绑定，其他都是静态绑定。

## 15、深拷贝和浅拷贝

如果一个类拥有资源，对该类的对象进行复制，如果资源重新分配，就是深拷贝，否则就是浅拷贝

- 深拷贝：该对象和原对象占用不同的内存空间，既**拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容**。
- 浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝**类中位于栈空间中的内容**。

当类的成员变量中有**指针变量**时，最好使用深拷贝。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。

## 16、编译时多态和运行时多态的区别

- 编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛型编程）
- 运行时多态：在程序运行过程中出现，发生在继承体系中，是指基类的指针或引用访问派生类的虚函数
- 区别
  - 时期不同：编译时多态发生在编译过程中，运行时多态发生在程序的运行过程中
  - 实现方式不同：编译时多态运行泛型编程实现，运行时多态借助虚函数来实现

## 17、如何让类不被继承

- 借助 final 关键字

- ```c++
  class Base final
  {
  };
  
  class Derive: public Base{ // error: cannot derive from 'final' base 'Base' in derived type 'Derive'
  };
  ```