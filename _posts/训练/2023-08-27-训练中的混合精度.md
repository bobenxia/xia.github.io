> https://zhuanlan.zhihu.com/p/622631376

## fp32\tf32\fp16\bf16 之间区别

![](https://pic4.zhimg.com/80/v2-5e80264a8fe8ffaf312d08a50ce103eb_1440w.webp)

- FP32：指数 8 位，尾数 23位，符号 1 位
- TF32：指数 8 位，尾数 10位，符号 1 位

- FP16：指数 5 位，尾数 10 位，符号 1位
- BF16：指数 8 位，尾数 7 位，符号 1 位。指数和 FP32 一致，则能表示的大数和 FP32 一致，尾数低于 FP16，则实际最小范围低于FP16。
- INT8：定数位 7 位，符号 1 位。范围[-128, 127]



## scale 参与过程

![](https://pic1.zhimg.com/80/v2-c7e72924e1f38c80da915d44b2d1d3b8_1440w.webp)



## 低精度带来的影响

> https://blog.csdn.net/guanyonglai/article/details/127058613
>
> https://zhuanlan.zhihu.com/p/651588659

### fp16 表示范围

链接一中的例子的总结。

以 fp16 举例子，首先看下 fp16 的表达公式：

$$(-1)^s * 2^{(e-b)} * (1+ m/1024)$$

其中： 

- $s$ 是符号位
- $e$ 是指数位，这里也就是 0~2^5，实际更小
- $m$ 是尾数位
- 其中b是指数偏置，根据[IEEE754](https://so.csdn.net/so/search?q=IEEE754&spm=1001.2101.3001.7020)标准一般把b定为2^(e-1)-1，

注意，一个正常的数据表示方法，不仅要能表示正常的整数小数，还要能表示NaN，无穷，那么上面的公式就需要份情况讨论：

1. e全为0，m全为0，表示数字0
2. e全为0，m不全为0，表示一个很小的数，计算方式为: (-1)^s * 2^(-14) * (0+m/2^10)  # 注意加号前为0，这里为什么是-14而非-15其实跟上面的(0+m/2^10)中的0有关，可以看下面第7小节
3. e全为1，m全为0，表示正负无穷
4. e全为1，m不全为0，表示NAN

因此表示正常数字的话，指数位最高是 11110，只能到达 30。

最大值： max = 2\*(30-15)\*(1+1023/1024) = 65504

最小值：min = 2\*(0-14)\*(0+1/1024) = 2^(-24)



### fp16 表示精度

总结的话：浮点数表示的数字越大，精度越低。

fp16 的表达公式是：$$(-1)^s * 2^{(e-15)} * (1+ m/1024)$$，其中 $m/1024$ 意味着前面的指数区表示的粒度为 $2^{(e-15)}/1024$。

举例子，比如当 $e=26$ 的时候，指数区域的数值范围是$[2^{11}, 2^{11}*(1+1023/1024)]$，取出前三个数分别为 $2^{11}*(1+0/1024)、2^{11}*(1+1/1024)、2^{11}*(1+2/1024)$，即 2048、2050、2052。

由上可以看出，当数值在 2048 到 4096，只能隔二取值；当数值在 1024 到 2048，只能隔一取一。不同的区间表现不一致，规则是**浮点数表示的数字越大，精度越低**。

## 类推到 bf16

bf16 的尾数位是 7 位，则分割为 $2^7=128$，数值在 128 到 256，隔一取一；数值在 256 到 512，隔一取二。

